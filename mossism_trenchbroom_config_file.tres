[gd_resource type="Resource" script_class="TrenchBroomGameConfig" load_steps=21 format=3 uid="uid://0yr5b47bkcky"]

[ext_resource type="Resource" uid="uid://d1ff5er8dyntn" path="res://fgd/new_resource.tres" id="1_e76po"]
[ext_resource type="Script" path="res://addons/qodot/src/resources/game-definitions/trenchbroom_game_config.gd" id="3_r5ceb"]
[ext_resource type="Texture2D" uid="uid://dt31kwgpmq7t0" path="res://icon.svg" id="6_thfo4"]

[sub_resource type="GDScript" id="GDScript_wu5ji"]
script/source = "## Enables transparent textures in Trenchbroom and other map editors.
## Does not affect appearance or functionality in Godot.
## Uses a pattern matching system to identify brushes, faces, or brush
## entities that should contain Trenchbroom tag attributes.
class_name TrenchBroomTag
extends Resource

enum TagMatchType {
	TEXTURE, ## Tag applies to any face with a texture matching the texture name.
	CONTENT_FLAG, ## Tag applies to any brush with a content flag matching the tag pattern.
	SURFACE_FLAG, ## Tag applies to any face with a surface flag matching the tag pattern.
	SURFACE_PARAM, ## Tag applies to any face with a special surface param. See Trenchbroom Manual for more info: https://trenchbroom.github.io/manual/latest/#special_brush_face_types
	CLASSNAME ## Tag applies to any brush entity with a class name matching the tag pattern.
}

## Name to define this tag. Not used as the matching pattern.
@export var tag_name: String

## The attributes applied to matching faces or brushes. Only \"_transparent\" is
## supported in Trenchbroom, which makes matching faces or brushes transparent.
@export var tag_attributes : Array[String] = [\"_transparent\"]

## Detemines how the tag is matched. See [constant TagMatchType].
@export var tag_match_type: TagMatchType

## A string that filters which flag, param, or classname to use. [code]*[/code]
## can be used as a wildcard to include multiple options.
## [b]Example:[/b] [code]trigger_*[/code] with [constant TagMatchType] [i]Classname[/i] will apply
## this tag to all brush entities with the [code]trigger_[/code] prefix.
@export var tag_pattern: String

## A string that filters which textures recieve these attributes. Only used with
## a [constant TagMatchType] of [i]Texture[/i].
@export var texture_name: String
"

[sub_resource type="Resource" id="Resource_rdtbq"]
script = SubResource("GDScript_wu5ji")
tag_name = "Trigger"
tag_attributes = Array[String](["transparent"])
tag_match_type = 4
tag_pattern = "trigger*"
texture_name = "trigger"

[sub_resource type="Resource" id="Resource_truot"]
script = SubResource("GDScript_wu5ji")
tag_name = "Detail"
tag_attributes = Array[String]([])
tag_match_type = 4
tag_pattern = "detail*"
texture_name = ""

[sub_resource type="Resource" id="Resource_yvyr0"]
script = SubResource("GDScript_wu5ji")
tag_name = "Clip"
tag_attributes = Array[String](["transparent"])
tag_match_type = 0
tag_pattern = "clip"
texture_name = ""

[sub_resource type="Resource" id="Resource_0q7hh"]
script = SubResource("GDScript_wu5ji")
tag_name = "Skip"
tag_attributes = Array[String](["transparent"])
tag_match_type = 0
tag_pattern = "skip"
texture_name = ""

[sub_resource type="GDScript" id="GDScript_uapgl"]
script/source = "@tool
class_name QodotFGDSolidClass
extends QodotFGDClass

enum SpawnType {
	WORLDSPAWN = 0, ## Is worldspawn
	MERGE_WORLDSPAWN = 1, ## Should be combined with worldspawn
	ENTITY = 2, ## Is its own separate entity
	GROUP = 3 ## Is a group
}

enum CollisionShapeType {
	NONE, ## Should have no collision shape
	CONVEX, ## Should have a convex collision shape
	CONCAVE ## Should have a concave collision shape
}

@export var spawn : String = QodotUtil.CATEGORY_STRING
## Controls whether a given SolidClass is the worldspawn, is combined with the worldspawn, or is spawned as its own free-standing entity
@export var spawn_type: SpawnType = SpawnType.ENTITY

@export var visual_build: String = QodotUtil.CATEGORY_STRING
## Controls whether a visual mesh is built for this SolidClass
@export var build_visuals := true

@export var collision_build : String = QodotUtil.CATEGORY_STRING
## Controls how collisions are built for this SolidClass
@export var collision_shape_type: CollisionShapeType = CollisionShapeType.CONVEX

@export var scripting: String = QodotUtil.CATEGORY_STRING
## The script file to associate with this SolidClass
## On building the map, this will be attached to any brush entities created via this classname
@export var script_class: Script

func _init():
	prefix = \"@SolidClass\"

func build_def_text() -> String:
	# Class prefix
	var res : String = prefix

	# Meta properties
	var base_str = \"\"
	var meta_props = meta_properties.duplicate()

	for base_class in base_classes:
		if not 'classname' in base_class:
			continue

		base_str += base_class.classname

		if base_class != base_classes.back():
			base_str += \", \"

	if base_str != \"\":
		meta_props['base'] = base_str

	for prop in meta_props:
		var value = meta_props[prop]
		res += \" \" + prop + \"(\"

		if value is AABB:
			res += \"%s %s %s, %s %s %s\" % [
				value.position.x,
				value.position.y,
				value.position.z,
				value.size.x,
				value.size.y,
				value.size.z
			]
		elif value is Color:
			res += \"%s %s %s\" % [
				value.r8,
				value.g8,
				value.b8
			]
		elif value is String:
			res += value

		res += \")\"

	res += \" = \" + classname

	var normalized_description = description.replace(\"\\n\", \" \").strip_edges()
	if normalized_description != \"\":
		res += \" : \\\"%s\\\" \" % [normalized_description]

	res += \"[\" + QodotUtil.newline()

	# Class properties
	for prop in class_properties:
		var value = class_properties[prop]

		var prop_val = null
		var prop_type := \"\"
		var prop_description: String = class_property_descriptions[prop] if prop in class_property_descriptions else \"\"

		if value is int:
			prop_type = \"integer\"
			prop_val = str(value)
		elif value is float:
			prop_type = \"float\"
			prop_val = \"\\\"\" + str(value) + \"\\\"\"
		elif value is String:
			prop_type = \"string\"
			prop_val = \"\\\"\" + value + \"\\\"\"
		elif value is Vector3:
			prop_type = \"string\"
			prop_val = \"\\\"%s %s %s\\\"\" % [
				value.x,
				value.y,
				value.z
			]
		elif value is Color:
			prop_type = \"color255\"
			prop_val = \"\\\"%s %s %s\\\"\" % [
				value.r8,
				value.g8,
				value.b8
			]
		elif value is Dictionary:
			prop_type = \"choices\"
			prop_val = \"[\" + \"\\n\"
			for choice in value:
				var choice_val = value[choice]
				prop_val += \"\\t\\t\" + str(choice_val) + \" : \\\"\" + choice + \"\\\"\\n\"
			prop_val += \"\\t]\"
		elif value is Array:
			prop_type = \"flags\"
			prop_val = \"[\" + \"\\n\"
			for arr_val in value:
				prop_val += \"\\t\\t\" + str(arr_val[1]) + \" : \\\"\" + str(arr_val[0]) + \"\\\" : \" + (\"1\" if arr_val[2] else \"0\") + \"\\n\"
			prop_val += \"\\t]\"
		elif value is NodePath:
			prop_type = \"target_destination\"
		elif value is Object:
			prop_type = \"target_source\"

		if(prop_val):
			res += \"\\t\"
			res += prop
			res += \"(\"
			res += prop_type
			res += \")\"

			if not value is Array:
				res += \" : \\\"\"
				res += prop_description
				res += \"\\\" \"

			if value is Dictionary or value is Array:
				res += \" = \"
			else:
				res += \" : \"

			res += prop_val
			res += QodotUtil.newline()

	res += \"]\" + QodotUtil.newline()

	return res
"

[sub_resource type="Resource" id="Resource_62v1y"]
script = SubResource("GDScript_uapgl")
spawn = "----------------------------------------------------------------"
spawn_type = 0
visual_build = "----------------------------------------------------------------"
build_visuals = true
collision_build = "----------------------------------------------------------------"
collision_shape_type = 1
scripting = "----------------------------------------------------------------"
class_options = "----------------------------------------------------------------"
classname = "worldspawn"
description = "World Entity"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_options = "----------------------------------------------------------------"
node_class = "StaticBody"
transient_node = false

[sub_resource type="Resource" id="Resource_chgsa"]
script = SubResource("GDScript_uapgl")
spawn = "----------------------------------------------------------------"
spawn_type = 1
visual_build = "----------------------------------------------------------------"
build_visuals = true
collision_build = "----------------------------------------------------------------"
collision_shape_type = 1
scripting = "----------------------------------------------------------------"
class_options = "----------------------------------------------------------------"
classname = "group"
description = "Brush Group"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_options = "----------------------------------------------------------------"
node_class = "StaticBody"
transient_node = false

[sub_resource type="Resource" id="Resource_1g3vd"]
script = SubResource("GDScript_uapgl")
spawn = "----------------------------------------------------------------"
spawn_type = 1
visual_build = "----------------------------------------------------------------"
build_visuals = true
collision_build = "----------------------------------------------------------------"
collision_shape_type = 1
scripting = "----------------------------------------------------------------"
class_options = "----------------------------------------------------------------"
classname = "detail"
description = "Detail Brush"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_options = "----------------------------------------------------------------"
node_class = "StaticBody"
transient_node = false

[sub_resource type="Resource" id="Resource_ho0jn"]
script = SubResource("GDScript_uapgl")
spawn = "----------------------------------------------------------------"
spawn_type = 1
visual_build = "----------------------------------------------------------------"
build_visuals = true
collision_build = "----------------------------------------------------------------"
collision_shape_type = 0
scripting = "----------------------------------------------------------------"
class_options = "----------------------------------------------------------------"
classname = "illusionary"
description = "Non-colliding Brush"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_options = "----------------------------------------------------------------"
node_class = "Spatial"
transient_node = false

[sub_resource type="GDScript" id="GDScript_nvisq"]
script/source = "@tool
class_name QodotFGDBaseClass
extends QodotFGDClass

func _init():
	prefix = \"@BaseClass\"
"

[sub_resource type="Resource" id="Resource_rvc7y"]
script = SubResource("GDScript_nvisq")
class_options = "----------------------------------------------------------------"
classname = "Light"
description = ""
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"_color": Color(1, 1, 1, 1),
"delay": {
"Inverse distance falloff": 1,
"Inverse distance squared": 2,
"Inverse distance squared B": 5,
"Linear falloff (Default)": 0,
"Local minlight": 4,
"No falloff": 3
},
"light": 300,
"mangle": Vector3(0.005, 0, 0),
"wait": 1
}
class_property_descriptions = {
"_color": "Light color",
"delay": "Attenuation",
"light": "Brightness",
"mangle": "Spotlight angle",
"wait": "Fade distance multiplier"
}
meta_properties = {
"color": Color(1, 1, 0.156863, 1)
}
node_options = "----------------------------------------------------------------"
node_class = ""
transient_node = false

[sub_resource type="GDScript" id="GDScript_uei1v"]
script/source = "@tool
class_name QodotFGDPointClass
extends QodotFGDClass

func _init():
	prefix = \"@PointClass\"

@export var scene : String = QodotUtil.CATEGORY_STRING

# The scene file to associate with this PointClass
# On building the map, this scene will be instanced into the scene tree
@export var scene_file: PackedScene

@export var scripting: String = QodotUtil.CATEGORY_STRING

# The script file to associate with this PointClass
# On building the map, this will be attached to any brush entities created
# via this classname if no scene_file is specified
@export var script_class: Script
"

[sub_resource type="GDScript" id="GDScript_qv2ld"]
script/source = "@tool
class_name QodotLight
extends QodotEntity

var light_node: Light3D = null

func update_properties():
	if not Engine.is_editor_hint():
		return
	
	for child in get_children():
		remove_child(child)
		child.queue_free()
	
	if 'mangle' in properties:
		light_node = SpotLight3D.new()
	
		var yaw = properties['mangle'].x
		var pitch = properties['mangle'].y
		light_node.rotate(Vector3.UP, deg_to_rad(180 + yaw))
		light_node.rotate(light_node.transform.basis.x, deg_to_rad(180 + pitch))
	
		if 'angle' in properties:
			light_node.set_param(Light3D.PARAM_SPOT_ANGLE, properties['angle'])
	else:
		light_node = OmniLight3D.new()
	
	var light_brightness = 300
	if 'light' in properties:
		light_brightness = properties['light']
		light_node.set_param(Light3D.PARAM_ENERGY, light_brightness / 100.0)
		light_node.set_param(Light3D.PARAM_INDIRECT_ENERGY, light_brightness / 100.0)
	
	var light_range := 1.0
	if 'wait' in properties:
		light_range = properties['wait']
	
	var normalized_brightness = light_brightness / 300.0
	light_node.set_param(Light3D.PARAM_RANGE, 16.0 * light_range * (normalized_brightness * normalized_brightness))
	
	var light_attenuation = 0
	if 'delay' in properties:
		light_attenuation = properties['delay']
	
	var attenuation = 0
	match light_attenuation:
		0:
			attenuation = 1.0
		1:
			attenuation = 0.5
		2:
			attenuation = 0.25
		3:
			attenuation = 0.15
		4:
			attenuation = 0
		5:
			attenuation = 0.9
		_:
			attenuation = 1
	
	light_node.set_param(Light3D.PARAM_ATTENUATION, attenuation)
	light_node.set_shadow(true)
	light_node.set_bake_mode(Light3D.BAKE_STATIC)
	
	var light_color = Color.WHITE
	if '_color' in properties:
		light_color = properties['_color']
	
	light_node.set_color(light_color)
	
	add_child(light_node)
	
	if is_inside_tree():
		var tree = get_tree()
		if tree:
			var edited_scene_root = tree.get_edited_scene_root()
			if edited_scene_root:
				light_node.set_owner(edited_scene_root)
"

[sub_resource type="Resource" id="Resource_tienq"]
script = SubResource("GDScript_uei1v")
scene = "----------------------------------------------------------------"
scripting = "----------------------------------------------------------------"
script_class = SubResource("GDScript_qv2ld")
class_options = "----------------------------------------------------------------"
classname = "light"
description = "Invisible light source"
qodot_internal = false
base_classes = Array[Resource]([SubResource("Resource_rvc7y")])
class_properties = {
"angle": 0.0
}
class_property_descriptions = {
"angle": "Rotation Angle"
}
meta_properties = {
"size": AABB(-8, -8, -8, 8, 8, 8)
}
node_options = "----------------------------------------------------------------"
node_class = "Spatial"
transient_node = false

[sub_resource type="GDScript" id="GDScript_umhju"]
script/source = "@tool
class_name QodotFGDFile
extends Resource

## A node used to to express a set of entity definitions that can be exproted

#psuedo-button to export
@export var export_file: bool:
	get:
		return export_file # TODOConverter40 Non existent get function 
	set(new_export_file):
		if new_export_file != export_file:
			do_export_file()
func do_export_file():
	if Engine.is_editor_hint() and get_fgd_classes().size() > 0:
				if target_folder.is_empty():
					print(\"Skipping export: No target folder\")
					return

				if fgd_name == \"\":
					print(\"Skipping export: Empty FGD name\")

				var fgd_file = target_folder + \"/\" + fgd_name + \".fgd\"

				print(\"Exporting FGD to \", fgd_file)
				var file_obj := FileAccess.open(fgd_file, FileAccess.WRITE)
				file_obj.store_string(build_class_text())
				file_obj.close()
@export var target_folder : String # (String, DIR, GLOBAL)
@export var fgd_name: String = \"Qodot\"
@export var base_fgd_files: Array[Resource] = [] # (Array, Resource)
@export var entity_definitions: Array[Resource] = [ # (Array, Resource)
	preload(\"res://addons/qodot/game_definitions/fgd/solid_classes/worldspawn_solid_class.tres\"),
	preload(\"res://addons/qodot/game_definitions/fgd/solid_classes/group_solid_class.tres\"),
	preload(\"res://addons/qodot/game_definitions/fgd/solid_classes/detail_solid_class.tres\"),
	preload(\"res://addons/qodot/game_definitions/fgd/solid_classes/illusionary_solid_class.tres\"),
	preload(\"res://addons/qodot/game_definitions/fgd/base_classes/light_base_class.tres\"),
	preload(\"res://addons/qodot/game_definitions/fgd/point_classes/light_point_class.tres\"),
]

func build_class_text() -> String:
	var res : String = \"\"

	for base_fgd in base_fgd_files:
		res += base_fgd.build_class_text()

	var entities = get_fgd_classes()
	for ent in entities:
		if ent.qodot_internal:
			continue
		var ent_text = ent.build_def_text()
		res += ent_text
		if ent != entities[-1]:
			res += \"\\n\"
	return res

#This getter does a little bit of validation. Providing only an array of non-null uniquely-named entity definitions
func get_fgd_classes() -> Array:
	var res : Array = []
	for cur_ent_def_ind in range(entity_definitions.size()):
		var cur_ent_def = entity_definitions[cur_ent_def_ind]
		if cur_ent_def == null:
			continue
		elif not (cur_ent_def is QodotFGDClass):
			printerr(\"Bad value in entity definition set at position %s! Not an entity defintion.\" % cur_ent_def_ind)
			continue
		res.append(cur_ent_def)
	return res

func get_entity_definitions() -> Dictionary:
	var res : Dictionary = {}

	for base_fgd in base_fgd_files:
		var fgd_res = base_fgd.get_entity_definitions()
		for key in fgd_res:
			res[key] = fgd_res[key]

	for ent in get_fgd_classes():
		if ent is QodotFGDPointClass or ent is QodotFGDSolidClass:
			var entity_def = ent.duplicate()
			var meta_properties := {}
			var class_properties := {}
			var class_property_descriptions := {}

			for base_class in _generate_base_class_list(entity_def):
				for meta_property in base_class.meta_properties:
					meta_properties[meta_property] = base_class.meta_properties[meta_property]

				for class_property in base_class.class_properties:
					class_properties[class_property] = base_class.class_properties[class_property]

				for class_property_desc in base_class.class_property_descriptions:
					class_property_descriptions[class_property_desc] = base_class.class_property_descriptions[class_property_desc]

			for meta_property in entity_def.meta_properties:
				meta_properties[meta_property] = entity_def.meta_properties[meta_property]

			for class_property in entity_def.class_properties:
				class_properties[class_property] = entity_def.class_properties[class_property]

			for class_property_desc in entity_def.class_property_descriptions:
				class_property_descriptions[class_property_desc] = entity_def.class_property_descriptions[class_property_desc]

			entity_def.meta_properties = meta_properties
			entity_def.class_properties = class_properties
			entity_def.class_property_descriptions = class_property_descriptions

			res[ent.classname] = entity_def
	return res

func _generate_base_class_list(entity_def : Resource, visited_base_classes = []) -> Array:
	var base_classes : Array = []
	
	visited_base_classes.append(entity_def.classname)
	
	# End recursive search if no more base_classes
	if len(entity_def.base_classes) == 0:
		return base_classes
	
	# Traverse up to the next level of hierarchy, if not already visited
	for base_class in entity_def.base_classes:
		if not base_class.classname in visited_base_classes:
			base_classes.append(base_class)
			base_classes += _generate_base_class_list(base_class, visited_base_classes)
		else:
			printerr(str(\"Entity '\", entity_def.classname,\"' contains cycle/duplicate to Entity '\", base_class.classname, \"'\"))

	return base_classes
"

[sub_resource type="Resource" id="Resource_8q00k"]
script = SubResource("GDScript_umhju")
export_file = false
target_folder = "/mnt/crucial/MISC/LinuxPrograms/TrenchBroom/share/TrenchBroom/games/mossism-qodot_4"
fgd_name = "Q"
base_fgd_files = Array[Resource]([ExtResource("1_e76po")])
entity_definitions = Array[Resource]([SubResource("Resource_62v1y"), SubResource("Resource_chgsa"), SubResource("Resource_1g3vd"), SubResource("Resource_ho0jn"), SubResource("Resource_rvc7y"), SubResource("Resource_tienq")])

[resource]
script = ExtResource("3_r5ceb")
export_file = false
trenchbroom_games_folder = "/mnt/crucial/MISC/LinuxPrograms/TrenchBroom/share/TrenchBroom/games"
game_name = "mossism-qodot_4"
icon = ExtResource("6_thfo4")
fgd_files = Array[Resource]([SubResource("Resource_8q00k")])
brush_tags = Array[Resource]([SubResource("Resource_rdtbq"), SubResource("Resource_truot")])
face_tags = Array[Resource]([SubResource("Resource_yvyr0"), SubResource("Resource_0q7hh")])
face_attrib_surface_flags = Array[Resource]([])
face_attrib_content_flags = Array[Resource]([])
